using System;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Odachi.Build.OptionsFileGenerator.IO;
using Odachi.Build.OptionsFileGenerator.Model;

namespace Odachi.Build.OptionsFileGenerator;

[Generator]
public class OptionsFileSourceGenerator : ISourceGenerator
{
    private readonly Func<string, TextWriter> _additionalFileCreator;
    private readonly string? _projectDirectory;

    public OptionsFileSourceGenerator()
        : this(File.CreateText)
    {
    }
    public OptionsFileSourceGenerator(Func<string, TextWriter> additionalFileCreator)
        : this(additionalFileCreator, null)
    {
    }
    public OptionsFileSourceGenerator(Func<string, TextWriter> additionalFileCreator, string? projectDirectory)
    {
        _additionalFileCreator = additionalFileCreator ?? throw new ArgumentNullException(nameof(additionalFileCreator));
        _projectDirectory = projectDirectory;
    }

    private void AddAnnotations(GeneratorExecutionContext context)
    {
        var annotationsSource = $@"// <auto-generated />

#nullable enable

using System;

internal enum OptionsFileFormat
{{
    /// <summary>
    /// Infer format from file name extension.
    /// </summary>
    Auto,
    /// <summary>
    /// Generate file as json.
    /// </summary>
    Json,
}}

[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
internal sealed class {OptionsFileConstants.BranchAttributeName}Attribute : Attribute
{{
    /// <summary>
    /// File path (absolute or relative to project file) where config file will be generated. When null, no file is generated for this class. Default value is null.
    /// </summary>
    public string? {OptionsFileConstants.BranchAttributeFileNamePropertyName} {{ get; set; }}

    /// <summary>
    /// Generated options file format. Default value is Auto.
    /// </summary>
    public OptionsFileFormat {OptionsFileConstants.BranchAttributeFormatPropertyName} {{ get; set; }} = OptionsFileFormat.Auto;

    /// <summary>
    /// Key under which this object is nested. Only used for root elements (= FileName is specified on this attribute). For deeply nested locations use colon (ex. 'Foo:Bar') as separator. Default value is null.
    /// </summary>
    public string? {OptionsFileConstants.BranchAttributeKeyPropertyName} {{ get; set; }}
}}

[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
internal sealed class {OptionsFileConstants.LeafAttributeName}Attribute : Attribute
{{
    /// <summary>
    /// Comment shown above the option.
    /// </summary>
    public string? {OptionsFileConstants.LeafAttributeCommentPropertyName} {{ get; set; }}

    /// <summary>
    /// Default value.
    /// </summary>
    public object? {OptionsFileConstants.LeafAttributeDefaultValuePropertyName} {{ get; set; }}
}}
";
        context.AddSource("Odachi.Build.OptionsFileGenerator.Annotations.g.cs", annotationsSource);
    }

    public void Execute(GeneratorExecutionContext context)
    {
        AddAnnotations(context);

        if (context.SyntaxReceiver is OptionsFileSyntaxReceiver syntaxReceiver)
        {
            string? projectDirectory;
            if (!string.IsNullOrEmpty(_projectDirectory))
            {
                // project directory is explicitly set (this is most likely from unit tests)
                projectDirectory = _projectDirectory!;
            }
            else if (!context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.projectdir", out projectDirectory))
            {
                // determine project directory from build props
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor("OFG0001", "Failed to determine project directory", "Failed to determine project directory while generating options files.", "Odachi.Build.OptionsFileGenerator", DiagnosticSeverity.Warning, true),
                    null
                ));
                return;
            }

            foreach (var optionsFile in syntaxReceiver.OptionsFiles)
            {
                var model = context.Compilation.GetSemanticModel(optionsFile.ClassDeclarationSyntax.SyntaxTree);

                if (model.GetDeclaredSymbol(optionsFile.ClassDeclarationSyntax) is not ITypeSymbol typeSymbol)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor("OFG0002", "Missing type symbol for options file", "Missing type symbol for options file {0}", "Odachi.Build.OptionsFileGenerator", DiagnosticSeverity.Warning, true),
                        optionsFile.AttributeSyntax.GetLocation(),
                        optionsFile.Name
                    ));
                    continue;
                }

                var properties = OptionsProperty.FindForType(typeSymbol).ToList();

                var path = Path.Combine(projectDirectory, optionsFile.Name);
                try
                {
                    using var textWriter = _additionalFileCreator(path);
                    using var writer = new JsonOptionsFileWriter(textWriter, optionsFile.Key);

                    writer.Write(properties);
                }
                catch (Exception ex)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor("OFG0002", "Failed to write options file", "Failed to write options file to path '{0}': {1}", "Odachi.Build.OptionsFileGenerator", DiagnosticSeverity.Warning, true),
                        optionsFile.AttributeSyntax.GetLocation(),
                        path,
                        ex.Message
                    ));
                }
            }
        }
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new OptionsFileSyntaxReceiver());
    }
}
