using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Odachi.Build.OptionsFileGenerator.Internal;
using Odachi.Build.OptionsFileGenerator.IO;
using Odachi.Build.OptionsFileGenerator.Model;

namespace Odachi.Build.OptionsFileGenerator;

[Generator]
public class OptionsFileSourceGenerator : IIncrementalGenerator
{
    private readonly Func<string, TextWriter> _additionalFileCreator;
    private readonly string? _projectDirectory;

    public OptionsFileSourceGenerator()
        : this(File.CreateText)
    {
    }
    public OptionsFileSourceGenerator(Func<string, TextWriter> additionalFileCreator)
        : this(additionalFileCreator, null)
    {
    }
    public OptionsFileSourceGenerator(Func<string, TextWriter> additionalFileCreator, string? projectDirectory)
    {
        _additionalFileCreator = additionalFileCreator ?? throw new ArgumentNullException(nameof(additionalFileCreator));
        _projectDirectory = projectDirectory;
    }

    private void AddAnnotations(IncrementalGeneratorPostInitializationContext context)
    {
        var annotationsSource = $@"// <auto-generated />

#nullable enable

using System;

namespace {OptionsFileConstants.NamespaceName};

internal enum OptionsFileFormat
{{
    /// <summary>
    /// Infer format from file name extension.
    /// </summary>
    Auto,
    /// <summary>
    /// Generate file as json.
    /// </summary>
    Json,
}}

[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
internal sealed class {OptionsFileConstants.BranchAttributeName} : Attribute
{{
    /// <summary>
    /// File path (absolute or relative to project file) where config file will be generated. When null, no file is generated for this class. Default value is null.
    /// </summary>
    public string? {OptionsFileConstants.BranchAttributeFileNamePropertyName} {{ get; set; }}

    /// <summary>
    /// Generated options file format. Default value is Auto.
    /// </summary>
    public OptionsFileFormat {OptionsFileConstants.BranchAttributeFormatPropertyName} {{ get; set; }} = OptionsFileFormat.Auto;

    /// <summary>
    /// Key under which this object is nested. Only used for root elements (= FileName is specified on this attribute). For deeply nested locations use colon (ex. 'Foo:Bar') as separator. Default value is null.
    /// </summary>
    public string? {OptionsFileConstants.BranchAttributeKeyPropertyName} {{ get; set; }}
}}

[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
internal sealed class {OptionsFileConstants.LeafAttributeName} : Attribute
{{
    /// <summary>
    /// Comment shown above the option.
    /// </summary>
    public string? {OptionsFileConstants.LeafAttributeCommentPropertyName} {{ get; set; }}

    /// <summary>
    /// Default value.
    /// </summary>
    public object? {OptionsFileConstants.LeafAttributeDefaultValuePropertyName} {{ get; set; }}
}}
";
        context.AddSource("Odachi.Build.OptionsFileGenerator.Annotations.g.cs", annotationsSource);
    }

    static ClassDeclarationSyntax? CollectOptionsBranchSyntax(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
	    var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

	    foreach (var attributeListSyntax in classDeclarationSyntax.AttributeLists)
	    {
		    foreach (var attributeSyntax in attributeListSyntax.Attributes)
		    {
				// we're looking only for branches that are supposed to generate files, so we can
				// safely ignore all attributes without any arguments as one needs to opt-in into
				// creating a file
			    if (attributeSyntax.ArgumentList?.Arguments.Count is null or <= 0)
			    {
				    continue;
			    }

			    if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
			    {
				    // can this happen? is it worth logging?
				    continue;
			    }

			    var fullName = attributeSymbol.ContainingType.ToDisplayString();
			    if (fullName != OptionsFileConstants.BranchAttributeFullName)
			    {
				    continue;
			    }

			    var hasFileNameAttribute = false;
			    foreach (var argument in attributeSyntax.ArgumentList.Arguments)
			    {
				    if (argument.NameEquals?.Name.Identifier.Text == OptionsFileConstants.BranchAttributeFileNamePropertyName)
				    {
					    hasFileNameAttribute = true;
					    break;
				    }
			    }
			    if (!hasFileNameAttribute)
			    {
				    return null;
			    }

			    return classDeclarationSyntax;
		    }
	    }

	    return null;
    }

    private void Execute(
	    SourceProductionContext sourceProductionContext,
	    string? projectDir,
	    Compilation compilation,
	    ImmutableArray<ClassDeclarationSyntax> rootOptionSyntax
	)
    {
	    if (rootOptionSyntax.IsDefaultOrEmpty)
	    {
		    return;
	    }

	    projectDir = _projectDirectory ?? projectDir;
	    if (string.IsNullOrEmpty(projectDir))
	    {
		    sourceProductionContext.ReportDiagnostic(Diagnostic.Create(
			    new DiagnosticDescriptor("OFG0001", "Failed to determine project directory", "Failed to determine project directory while generating options files.", "Odachi.Build.OptionsFileGenerator", DiagnosticSeverity.Warning, true),
			    null
		    ));
		    return;
	    }

	    foreach (var rootOption in rootOptionSyntax)
	    {
		    var model = compilation.GetSemanticModel(rootOption.SyntaxTree);

		    if (model.GetDeclaredSymbol(rootOption) is not ITypeSymbol typeSymbol)
		    {
				sourceProductionContext.ReportDiagnostic(Diagnostic.Create(
					new DiagnosticDescriptor("OFG0002", "Missing type symbol for options file", "Missing type symbol for options file {0}", "Odachi.Build.OptionsFileGenerator", DiagnosticSeverity.Warning, true),
					rootOption.GetLocation(),
					"todo"//optionsFile.Name
				));
				continue;
		    }

		    string? fileName = null;
		    OptionsFileFormat fileFormat = OptionsFileFormat.Auto;
		    string? fileKey = null;

		    foreach (var attribute in typeSymbol.GetAttributes())
		    {
			    if (attribute.NamedArguments.Length <= 0)
			    {
				    continue;
			    }

			    if (!attribute.IsOptionsBranchAttributeType())
			    {
				    continue;
			    }

			    fileName = null;
			    fileFormat = OptionsFileFormat.Auto;
			    fileKey = null;

			    foreach (var argument in attribute.NamedArguments)
			    {
				    switch (argument.Key)
				    {
					    case OptionsFileConstants.BranchAttributeFileNamePropertyName:
						    fileName = (string?)argument.Value.Value;
						    break;

					    case OptionsFileConstants.BranchAttributeFormatPropertyName:
						    fileFormat = (OptionsFileFormat)(int)argument.Value.Value!;
						    break;

					    case OptionsFileConstants.BranchAttributeKeyPropertyName:
						    fileKey = (string?)argument.Value.Value;
						    break;

					    default:
						    sourceProductionContext.ReportDiagnostic(Diagnostic.Create(
							    new DiagnosticDescriptor("OFG0003", "Unexpected options file argument", "Unexpected options file argument {0}", "Odachi.Build.OptionsFileGenerator", DiagnosticSeverity.Warning, true),
							    rootOption.GetLocation(),
							    argument.Key
						    ));
						    continue;
				    }
			    }

			    if (string.IsNullOrEmpty(fileName))
			    {
				    continue;
			    }

			    var optionsFile = new OptionsFile()
			    {
				    Name = fileName!,
				    Format = fileFormat,
				    Key = fileKey,

				    Properties = OptionsProperty.FindForType(typeSymbol).ToList(),
				};

			    // render
			    var path = Path.Combine(projectDir, optionsFile.Name);
			    try
			    {
				    using var textWriter = _additionalFileCreator(path);
				    using var writer = new JsonOptionsFileWriter(textWriter, optionsFile.Key);

				    writer.Write(optionsFile.Properties);
			    }
			    catch (Exception ex)
			    {
				    sourceProductionContext.ReportDiagnostic(Diagnostic.Create(
					    new DiagnosticDescriptor("OFG0002", "Failed to write options file", "Failed to write options file to path '{0}': {1}", "Odachi.Build.OptionsFileGenerator", DiagnosticSeverity.Warning, true),
					    attribute.ApplicationSyntaxReference?.GetSyntax().GetLocation() ?? rootOption.GetLocation(),
					    path,
					    ex.Message
				    ));
			    }
		    }
	    }
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
	    context.RegisterPostInitializationOutput(AddAnnotations);

	    // typed explicitly since we filter out nulls but linq cannot handle it
	    IncrementalValueProvider<ImmutableArray<ClassDeclarationSyntax>> optionBranchProvider = context.SyntaxProvider
		    .CreateSyntaxProvider(
			    static (node, _) => node is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
			    CollectOptionsBranchSyntax
		    )
		    .Where(hit => hit != null)
		    .Collect()!;

	    var projectDirProvider = context.AnalyzerConfigOptionsProvider
		    .Select(static (provider, _) => {
			    if (!provider.GlobalOptions.TryGetValue("build_property.projectdir", out var projectDirectory))
			    {
				    return null;
			    }

			    return projectDirectory;
		    });

	    var pipeline = optionBranchProvider
		    .Combine(context.CompilationProvider)
		    .Combine(projectDirProvider);

	    context.RegisterImplementationSourceOutput(
		    pipeline,
		    (sourceProductionContext, source) => Execute(sourceProductionContext, source.Right, source.Left.Right, source.Left.Left)
		);
    }
}
